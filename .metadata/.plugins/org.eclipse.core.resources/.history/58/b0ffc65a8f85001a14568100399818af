package com.aeox.jkaiser.loader;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Modifier;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import com.aeox.jkaiser.core.Task;

import lombok.extern.log4j.Log4j2;

@Log4j2
@Service
public class TaskLoader {

	public static final String pluginsFolder = "./plugins";
	private ExtensionLoader<Task> extensionLoader;

	public TaskLoader() {
		final File file = new File(pluginsFolder);
		file.mkdir();
		extensionLoader = new ExtensionLoader<>();
	}

	@Scheduled(fixedDelay = 3000)
	public void loadTasks() throws IOException {
		log.info("Loading new jars from folder...");
		final List<File> paths = this.getJarPlugins();
		paths.forEach((jarFile) -> {
			log.info("Checking jar {}", jarFile);
			try {
				this.loadPlugin(jarFile);
			} catch (IOException e) {
				e.printStackTrace();
			}
		});
	}

	public List<File> getJarPlugins() throws IOException {
		try (Stream<Path> walk = Files.walk(Paths.get(pluginsFolder))) {
			return walk.filter((path) -> {
				return Files.isRegularFile(path)
						&& new File(path.toAbsolutePath().toString()).getAbsolutePath().endsWith(".jar");
			}).map(path -> {
				return new File(path.toAbsolutePath().toString());
			}).collect(Collectors.toList());
		} catch (IOException e) {
			throw e;
		}
	}

	public List<Task<?>> recoverClass(final File file) throws IOException, ClassNotFoundException {
		final List<Task<?>> pluginTasks = new LinkedList<>();
		try (final JarFile jarFile = new JarFile(file)) {
			final Enumeration<JarEntry> allEntries = jarFile.entries();
			while (allEntries.hasMoreElements()) {
				JarEntry entry = (JarEntry) allEntries.nextElement();
				String name = entry.getName();
				if (!entry.isDirectory() && name.endsWith(".class")) {
		            final String className = name.substring(0, name.lastIndexOf('.')).replace('/', '.');
		            final Class<? extends Task<?>> cls = Class.forName(className);
		            
		            if ((cls.getModifiers() & Modifier.ABSTRACT) != 0) { // Only instanciable classes
		                continue;
		            }

		            pluginTasks.add(cls.getDeclaredConstructor().newInstance());
					System.out.println(className);
				}
			}
		}
	}
}
